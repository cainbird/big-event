# 项目笔记

## 10.19

### 开发接口流程

1. 明确需求->用户如何使用功能
2. 阅读接口文档->明确接口输入和输出
3. 思路分析->分析代码逻辑
4. 开发
5. 测试

### 实现用户注册功能

1. 如果返回的格式是固定的情况下，可以考虑创建一个泛型实体用来返回结果。
2. 使用Lombok，可以自动帮实体类生成getter，setter， toString等函数，并且这很重要。因为SpringBoot自动把返回值转成josn格式需要用这些函数。（需要在pom中引入Lombok的jar包）
3. 在mapper接口中实现对数据的操作时，如果传入的是多个变量，要用`@Param("变量名")`对变量和sql语句做对应，否则会报找不到变量的错误。

整体逻辑：按照用户名查用户，存在则用户名重复，否则可以创建，创建时将密码加密后通过mapper创建记录。

### 接口参数校验

1. 若在接口文档中明确对一些参数的格式做了要求，则需要在Controller中做参数校验。因为使用if,else太繁琐，所以推荐使用`@Pattern(regexp = "^正则表达式$")`，加在接收的参数前自动做格式校验。需要在Controller类的上方加上`@Validated`，这样Spring才会识别到`@Pattern`。（需要在pom中引入spring-boot-starter-validation的jar包）
2. 但是若之作校验，就会直接返回访问500，并不能清晰的反馈问题，所以可以创建全局异常处理器。需要在类上加上`@RestControllerAdvice`，明确这是异常处理控制类。在每个处理异常的方法上加上`@ExceptionHandler(异常.class)`，表明方法处理的异常类，并在方法中实现对异常的处理和反馈，具体操作和Controller类似，异常了就返回这个，没异常就返回那个。

## 10.20

### 实现登录功能

1. 根据用户名查找用户，存在则继续对比密码，否则返回"用户名错误"，密码需要加密后对比，一样则"登陆成功"，否则返回"密码错误"
2. 登录成功后返回用户的JWT token令牌（登录认证）

### JWT token令牌生成和校验

1. JWT令牌的结构是 头部.有效载荷.签名
    1. 头部：加密算法和令牌类型
    2. 有效载荷：自定义信息。存放业务数据，减少数据库查询频率。(使用Base64来进行转换，这并不是加密算法，所以内容可以被获取，不能存放敏感信息)
    3. 数字签名：将头部和有效载荷经过密钥进行加密后的结果
2. JWT token令牌的意义是保证，用户只有在登陆后才能访问特定资源。并且token令牌也有生存时间，超时会失效。
3. JWT(JSON Web Token)的生成工具需要在pom文件中引入java-jwt jar包。
4. JWT令牌验证失败原因：
    1. 如果篡改了头部和载荷部分的数据，那么验证失败（令牌非法，拒绝访问）
    2. 如果密钥改了，验证失败（生成JWT令牌和验证JWT令牌的加密算法和密钥要求是一样的）
    3. token过期了也会验证失败（令牌非法，拒绝访问）

整体逻辑：用户登录时生成JWT令牌，并返回给用户。用户在访问内部指定资源时，对用户的JWT令牌进行验证，验证成功->提供服务，否则拒绝访问。

### 实现登录认证

1. 登录认证主要保证用户是在登录的状态下对网站资源进行访问的。
2. 主要采用的方式是在登录时给用户生成token令牌并返回，在被访问资源时对接收的请求头"Authorization"中的token令牌进行验证。
3. 但是如果对每一个资源页面接口都加一个验证功能会显得代码非常的臃肿，所以针对这个需求，选择新建一个拦截器，对访问这些接口的请求信息先做token验证，再决定是阻止访问还是放行。（需要注意，把登录和注册接口去除，这两个不应被拦截）
4. 拦截器的创建主要是继承`HandlerInterceptor`类，并重写`preHandle`方法。把token验证代码实现在这里就可以。对请求头的获取，需要通过对参数request的使用`request.getHeader("Authorization");`来实现。
5. 实现后，需要把拦截器加入到web配置中。需要创建一个配置类继承`WebMvcConfigurer`类，并重写`addInterceptors`方法。

这样对于网站的资源访问就可以实现token验证。

## 10.23

### 获取用户详细信息

1. 通过解析请求头携带的"Authorization"来获取token，对token字符串进行解析，得到用户的id和用户名。
2. 通过用户名查询的方法来获取用户信息。
3. 如果在返回时不希望springmvc把这个属性转成json格式，就需要在实体类这个属性上方使用`@JsonIgnore`注解。
4. 如果在实体类中命名方式是驼峰命名法，但是在数据表中的命名方式是下划线命名法，就需要在yml文件中使用下面的配置来开启转换：

    ```yml
    mybatis:
        configuration:
            map-underscore-to-camel-case: true
    ```

如果使用直接在controller中解析请求头的方式来获取token，就会重复token解析操作，使代码冗余。\
为了减少重复操作的次数，可以采用一个容器来提前存储在拦截器中已经解析的token结果。\
但是如果直接使用全局变量存储，很有可能会存在线程不安全的情况。所以推荐使用`ThreadLocal`来存储。因为这创建的是线程局部变量，保证只在线程内部使用。不同线程之间不会互相调用。\
`ThreadLocal`有两个方法，set()和get()，可以存储和获取。此外还有remove()方法，在使用后要把空间释放，否则变量会一直存在，会导致内存泄漏。\
通过在拦截器中重写`afterCompletion`方法，可以在线程结束后执行remove()方法释放资源。
